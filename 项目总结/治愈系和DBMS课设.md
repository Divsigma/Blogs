# 前言

&ensp;&ensp;&ensp;&ensp;此篇旨在整理一些大二做Web项目时碰到的问题及解决方案，主要集中在后端。此篇意在用于积累经验并指导深入思考（应该会不断更新）。



<br />

<br />

# 正文

## 1. 后端代码

### 1. `DBMS课设`中用到了编程式事务+悲观锁防止超卖，事务包含了扣库存、下单、拨款整个流程。这样做有什么问题？

- 1）编程式事务不灵活
  - 奈何自己写的框架太垃圾。但Laravel和ThinkPHP中似乎也没有提供`声明式事务`的写法
- 2）长事务有弊端
  - A）导致主从复制延迟，增加了数据库读取数据压力：
    - MySQL引入了`Metadata Lock`，一张在一个事务中进行DML操作的表无法被另一个事务进行DDL操作（需要等待`Metadata Lock`）。
    - 解决方案：将下单和拨款抽离，并用`update tb set x=x-amount where x>0`代替锁机制下的`查询、判断再修改`流程（InnoDB在`REPEATABLE_READ`隔离级别下，对采用锁机制的读写会加*row-level lock*）；监控`information_schema.innodb_trx`表将运行时间过长的读事务杀死
  - B）事务拥有的锁过多容易造成请求阻塞甚至死锁：
- 3）悲观锁和乐观锁选择待考究
  - 理论上，悲观锁较乐观锁保证了更强的一致性，而且没有悲观锁的重试开销，但它带来了更大的更新开销（加锁）和死锁问题（乐观锁没有死锁问题）。所以说悲观锁更适用于重试开销大/多写少读的场景，乐观锁更适用于要求快响应/多读少写的场景。
  - 虽然乐观锁没有死锁问题，但可能有数据一致性问题（如自定义主键ID管理时，见https://segmentfault.com/q/1010000009251675/a-1020000009257872）
  - 事实上，高并发写时采用悲观锁应该会导致数据库性能下降，此时可以考虑用缓存数据库（如Redis）进行并发写，再异步写入数据库（此时则抛弃MySQL提供的锁机制）





<br />

<br />

## 2. 数据库



<br />

<br />

## 3. 服务器



<br />

<br />

## 4. 系统

### 1. 设计一个秒杀系统的基本思路？

- `@阿里云云栖号`和`@敖丙`的回答可以看看，主要是：请求上游限流+前端置灰+URL动态化（防黄牛）+恶意请求拦截+Nginx（负载均衡）+Redis集群（抗读多写少的请求，同时考虑数据同步）+异步入库



<br />

<br />

## 5. 前端代码



