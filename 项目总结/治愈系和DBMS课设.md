# 前言

&ensp;&ensp;&ensp;&ensp;此篇旨在整理一些大二做Web项目时碰到的问题及解决方案，主要集中在后端。此篇意在用于积累经验并指导深入思考（应该会不断更新）。



<br />

<br />

# 正文

### 1. `DBMS课设`中用到了编程式事务+悲观锁防止超卖，事务包含了扣库存、下单、拨款整个流程。这样做有什么问题？

- 1）编程式事务不灵活
  - 奈何自己写的框架太垃圾。但Laravel和ThinkPHP中似乎也没有提供`声明式事务`的写法
- 2）长事务有弊端
  - A）导致主从复制延迟，增加了数据库读取数据压力：
    - MySQL引入了`Metadata Lock`，一张在一个事务中进行DML操作的表无法被另一个事务进行DDL操作（需要等待`Metadata Lock`）。
    - 解决方案：将下单和拨款抽离，并用`update tb set x=x-amount where x>0`代替锁机制下的`查询、判断再修改`流程（InnoDB在`REPEATABLE_READ`隔离级别下，对采用锁机制的读写会加*row-level lock*）；监控`information_schema.innodb_trx`表将运行时间过长的读事务杀死
  - B）事务拥有的锁过多容易造成请求阻塞甚至死锁：
- 3）悲观锁和乐观锁选择待考究
  - 理论上，悲观锁较乐观锁保证了更强的一致性，而且没有悲观锁的重试开销，但它带来了更大的更新开销（加锁）和死锁问题（乐观锁没有死锁问题）。所以说悲观锁更适用于重试开销大/多写少读的场景，乐观锁更适用于要求快响应/多读少写的场景。
  - 虽然乐观锁没有死锁问题，但可能有数据一致性问题（如自定义主键ID管理时，见https://segmentfault.com/q/1010000009251675/a-1020000009257872）
  - 事实上，高并发写时采用悲观锁应该会导致数据库性能下降，此时可以考虑用缓存数据库（如Redis）进行并发写，再异步写入数据库（此时则抛弃MySQL提供的锁机制）

### 2. 用MySQL的事务和锁机制可能扛不住高并发的超卖，此时有什么办法？

- 1）使用读写性能更好的Redis进行抢货请求处理
- 

- 2）用队列串行化请求
- 

> - 关于如何设计一个秒杀系统，可以看看知乎`@阿里云云栖号`和`@敖丙`的回答，主要是思想是：请求上游限流 + 前端置灰 + URL动态化防黄牛 + 恶意请求拦截 + Nginx负载均衡 + Redis集群（抗读多写少的请求，必须考虑数据同步） + 异步入库。
>
>   链接：https://www.zhihu.com/question/54895548
>
> - 关于高并发的数据库端解决方案，传统思路有：为数据库部署单台服务器 + 用基于内存的数据库缓存时效性要求不高的数据（治愈系用了Redis缓存歌单、排行榜） + 数据库读写分离（主从分离）  + 分表分库（垂直拆分：按业务分库/按字段分表；水平拆分：按字段范围分库分表）。缓存占用昂贵的内存，但分离会导致数据不一致问题，所以需要trade-off。
>
>   链接：https://cloud.tencent.com/developer/article/1187865
>
> - InnoDB有缓存机制，但依旧不够用Redis快，关于性能对比：https://segmentfault.com/a/1190000005034197
>
>   （**如果说选用Redis是因为它基于内存读写快，那`MEMORY`引擎的MySQL跟Redis哪个更好？？**）
>
> - 



<br />

<br />

----



<div align="center">by Divsigma@github.com</div>

