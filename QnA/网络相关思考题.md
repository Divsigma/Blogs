1、一端close(socket)时，发送FIN还是RST？发送RST会有什么问题？如何解决？

内核根据**接收缓冲**是否有数据，决定发送FIN还是RST。

https://z.itpub.net/article/detail/E07055E62740F8C59E1649519A7F1A41

当一端接收缓冲还有数据时调用了close，此时它会清空接收缓冲并向对端发送RST，这可能导致**对端接收缓冲**中的数据无法被顺利读取（？），导致对端程序出错。

https://www.starduster.me/2019/07/06/socket-lingering-and-closing/

↑使用SO_LINGER似乎不能解决？↑而且内核的实现还会导致非阻塞socket阻塞？Nginx是怎么处理lingering close的？（lingering close处理是怎么一回事？）





2、一端调用shutdown和close的区别，此时对端recv返回值的区别？





3、如何知道对端调用了close？





4、client调用close时，发送buf有数据，此时发送buf最后一块数据会被设置成FIN，此时server recv返回值是多少？client调用close时发送buf无数据，此时client仅发送FIN，此时server recv返回值是0，为什么《Linux多线程服务器编程》中8.7.1此时调用handleClose()，而前一种情况不调用？



5、LT和ET的POLLIN和POLLOUT触发条件分别是？

（1）LT的POLLIN触发条件：内核接收缓冲存在数据可读

（2）ET的POLLIN触发条件：内核接收缓冲有新数据到达

（3）LT的POLLOUT触发条件：内核发送缓冲存在空间可写新数据

（4）ET的POLLOUT触发条件（？）：内核发送缓冲在满载状态发送了数据（刚好空出可写新数据的空间）



6、LT和ET触发的非阻塞send应该怎么写？

（1）LT的非阻塞send（方法1）：

可参照muduo的TCPConnection::sendInLoop()，需要设置回调handleWrite()，sendInLoop()无法一次性发送完毕时将socket的POLLOUT（writable事件）加入Poller，并保存未发送的数据，后续回调handleWrite()发送剩余数据。handleWrite()中**每次调用1次send**并检查数据是否发送完毕，若发送完毕要及时将socket的POLLOUT（writable事件）移出Poller。

《Linux多线程服务器编程》8.8中，作者认为send应该是ET的。LT的send需要控制好关注writable事件的时机，否则会导致busy loop（即不能一直关注writable事件），所以写起来比较麻烦。

（2）ET的非阻塞send（方法1）：

需要设置回调handleWrite()，handleWrite()中**循环调用send**，直到返回EAGAIN（或EWOULDBLOCK）或发送完毕。可以持续关注writable事件。如果handleWrite()在处理过程中发生改变，则需要在改变回调函数后，执行一次新的回调函数。

（为什么Nginx每次send后发现没有发送完毕时，都要再往epoll注册一次写？如ngx_http_discarded_request_body_handler。这个注册是CTL_MOD还是CTL_ADD还是修改ngx_event_t的active位？）



7、LT和ET的非阻塞recv应该怎么写？

（1）LT的非阻塞recv（方法1）：

可参照muduo的TCPConnection::handleRead()中的inputBuffer_.readFd()，需要设置回调handleRead()。handleRead()**每次调用1次readv**，《Linux多线程服务器编程》的8.7.2中提到LT保证数据不会丢失（我觉得应该也不会“卡死”在wait）、也能保证多个连接readv的公平性。同时还分析了通常一次readv就能读完全部数据的原因（即时延带宽积最多为几十KiB，一两个以太网frame）。

《Linux多线程服务器编程》8.8中，作者认为recv应该是LT模式的。

相比ET有啥好处？

（2）ET的非阻塞recv（方法1）：

设置回调handleRead()，handleRead()中**循环readv**（即至少两次recv），直至返回EAGAIN。如果处理过程中handleRead()发生改变（如Nginx中先用一个函数接收请求行再用一个函数接收请求头），则需要在改变回调函数后，执行一次新的回调函数。

（为什么Nginx每次recv后发现EAGAIN时，都要再往epoll注册一次读？如ngx_http_process_request_line。这个注册是CTL_MOD还是CTL_ADD还是修改ngx_event_t的active位？--不会注册，ngx_handle_read_event是尝试添加）



8、EPOLLONESHOT可以在LT模式下使用吗？意义何在？LT模式如何防止多个线程处理同一个socket？



9、同一个fd多次加入epoll/poll/select会发生什么？



